(* autogenerated from github.com/mjschwenne/grackle/example *)
From New.golang Require Import defn.
Require Export New.code.fmt.
Require Export New.code.github_com.tchajed.marshal.

Definition main : go_string := "github.com/mjschwenne/grackle/example".

Module main.
Section code.
Context `{ffi_syntax}.


Definition Calendar : go_type := structT [
  "events" :: sliceT
].

Definition TimeStamp : go_type := structT [
  "hour" :: uint32T;
  "minute" :: uint32T;
  "second" :: uint32T
].

Definition Event : go_type := structT [
  "id" :: uint32T;
  "name" :: stringT;
  "startTime" :: TimeStamp;
  "endTime" :: TimeStamp
].

(* go: calendar.go:11:6 *)
Definition MarshalCalendar : val :=
  rec: "MarshalCalendar" "prefix" "c" :=
    exception_do (let: "c" := (mem.alloc "c") in
    let: "prefix" := (mem.alloc "prefix") in
    let: "enc" := (mem.alloc (type.zero_val #sliceT)) in
    let: "$r0" := (![#sliceT] "prefix") in
    do:  ("enc" <-[#sliceT] "$r0");;;
    let: "$r0" := (let: "$a0" := (![#sliceT] "enc") in
    let: "$a1" := (s_to_w64 (let: "$a0" := (![#sliceT] (struct.field_ref #Calendar #"events"%go "c")) in
    slice.len "$a0")) in
    (func_call #marshal.marshal #"WriteInt"%go) "$a0" "$a1") in
    do:  ("enc" <-[#sliceT] "$r0");;;
    let: "$r0" := (let: "$a0" := (![#sliceT] "enc") in
    let: "$a1" := (![#sliceT] (struct.field_ref #Calendar #"events"%go "c")) in
    let: "$a2" := (func_call #example.main #"MarshalEvent"%go) in
    (func_call #marshal.marshal #"WriteSlice"%go #Event) "$a0" "$a1" "$a2") in
    do:  ("enc" <-[#sliceT] "$r0");;;
    return: (![#sliceT] "enc")).

(* go: calendar.go:20:6 *)
Definition UnmarshalCalendar : val :=
  rec: "UnmarshalCalendar" "s" :=
    exception_do (let: "s" := (mem.alloc "s") in
    let: "enc" := (mem.alloc (type.zero_val #sliceT)) in
    let: "$r0" := (![#sliceT] "s") in
    do:  ("enc" <-[#sliceT] "$r0");;;
    let: "events" := (mem.alloc (type.zero_val #sliceT)) in
    let: "eventsLen" := (mem.alloc (type.zero_val #uint64T)) in
    let: ("$ret0", "$ret1") := (let: "$a0" := (![#sliceT] "enc") in
    (func_call #marshal.marshal #"ReadInt"%go) "$a0") in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    do:  ("eventsLen" <-[#uint64T] "$r0");;;
    do:  ("enc" <-[#sliceT] "$r1");;;
    let: ("$ret0", "$ret1") := (let: "$a0" := (![#sliceT] "enc") in
    let: "$a1" := (![#uint64T] "eventsLen") in
    let: "$a2" := (func_call #example.main #"UnmarshalEvent"%go) in
    (func_call #marshal.marshal #"ReadSlice"%go #Event) "$a0" "$a1" "$a2") in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    do:  ("events" <-[#sliceT] "$r0");;;
    do:  ("enc" <-[#sliceT] "$r1");;;
    return: (let: "$events" := (![#sliceT] "events") in
     struct.make #Calendar [{
       "events" ::= "$events"
     }], ![#sliceT] "enc")).

(* go: event.go:14:6 *)
Definition MarshalEvent : val :=
  rec: "MarshalEvent" "prefix" "e" :=
    exception_do (let: "e" := (mem.alloc "e") in
    let: "prefix" := (mem.alloc "prefix") in
    let: "enc" := (mem.alloc (type.zero_val #sliceT)) in
    let: "$r0" := (![#sliceT] "prefix") in
    do:  ("enc" <-[#sliceT] "$r0");;;
    let: "$r0" := (let: "$a0" := (![#sliceT] "enc") in
    let: "$a1" := (![#uint32T] (struct.field_ref #Event #"id"%go "e")) in
    (func_call #marshal.marshal #"WriteInt32"%go) "$a0" "$a1") in
    do:  ("enc" <-[#sliceT] "$r0");;;
    let: "nameByte" := (mem.alloc (type.zero_val #sliceT)) in
    let: "$r0" := (string.to_bytes (![#stringT] (struct.field_ref #Event #"name"%go "e"))) in
    do:  ("nameByte" <-[#sliceT] "$r0");;;
    let: "$r0" := (let: "$a0" := (![#sliceT] "enc") in
    let: "$a1" := (s_to_w64 (let: "$a0" := (![#sliceT] "nameByte") in
    slice.len "$a0")) in
    (func_call #marshal.marshal #"WriteInt"%go) "$a0" "$a1") in
    do:  ("enc" <-[#sliceT] "$r0");;;
    let: "$r0" := (let: "$a0" := (![#sliceT] "enc") in
    let: "$a1" := (![#sliceT] "nameByte") in
    (func_call #marshal.marshal #"WriteBytes"%go) "$a0" "$a1") in
    do:  ("enc" <-[#sliceT] "$r0");;;
    let: "$r0" := (let: "$a0" := (![#sliceT] "enc") in
    let: "$a1" := (![#TimeStamp] (struct.field_ref #Event #"startTime"%go "e")) in
    (func_call #example.main #"MarshalTimeStamp"%go) "$a0" "$a1") in
    do:  ("enc" <-[#sliceT] "$r0");;;
    let: "$r0" := (let: "$a0" := (![#sliceT] "enc") in
    let: "$a1" := (![#TimeStamp] (struct.field_ref #Event #"endTime"%go "e")) in
    (func_call #example.main #"MarshalTimeStamp"%go) "$a0" "$a1") in
    do:  ("enc" <-[#sliceT] "$r0");;;
    return: (![#sliceT] "enc")).

(* go: event.go:27:6 *)
Definition UnmarshalEvent : val :=
  rec: "UnmarshalEvent" "s" :=
    exception_do (let: "s" := (mem.alloc "s") in
    let: "enc" := (mem.alloc (type.zero_val #sliceT)) in
    let: "$r0" := (![#sliceT] "s") in
    do:  ("enc" <-[#sliceT] "$r0");;;
    let: "id" := (mem.alloc (type.zero_val #uint32T)) in
    let: "name" := (mem.alloc (type.zero_val #stringT)) in
    let: "startTime" := (mem.alloc (type.zero_val #TimeStamp)) in
    let: "endTime" := (mem.alloc (type.zero_val #TimeStamp)) in
    let: ("$ret0", "$ret1") := (let: "$a0" := (![#sliceT] "enc") in
    (func_call #marshal.marshal #"ReadInt32"%go) "$a0") in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    do:  ("id" <-[#uint32T] "$r0");;;
    do:  ("enc" <-[#sliceT] "$r1");;;
    let: "nameLen" := (mem.alloc (type.zero_val #uint64T)) in
    let: "nameBytes" := (mem.alloc (type.zero_val #sliceT)) in
    let: ("$ret0", "$ret1") := (let: "$a0" := (![#sliceT] "enc") in
    (func_call #marshal.marshal #"ReadInt"%go) "$a0") in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    do:  ("nameLen" <-[#uint64T] "$r0");;;
    do:  ("enc" <-[#sliceT] "$r1");;;
    let: ("$ret0", "$ret1") := (let: "$a0" := (![#sliceT] "enc") in
    let: "$a1" := (![#uint64T] "nameLen") in
    (func_call #marshal.marshal #"ReadBytesCopy"%go) "$a0" "$a1") in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    do:  ("nameBytes" <-[#sliceT] "$r0");;;
    do:  ("enc" <-[#sliceT] "$r1");;;
    let: "$r0" := (string.from_bytes (![#sliceT] "nameBytes")) in
    do:  ("name" <-[#stringT] "$r0");;;
    let: ("$ret0", "$ret1") := (let: "$a0" := (![#sliceT] "enc") in
    (func_call #example.main #"UnmarshalTimeStamp"%go) "$a0") in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    do:  ("startTime" <-[#TimeStamp] "$r0");;;
    do:  ("enc" <-[#sliceT] "$r1");;;
    let: ("$ret0", "$ret1") := (let: "$a0" := (![#sliceT] "enc") in
    (func_call #example.main #"UnmarshalTimeStamp"%go) "$a0") in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    do:  ("endTime" <-[#TimeStamp] "$r0");;;
    do:  ("enc" <-[#sliceT] "$r1");;;
    return: (let: "$id" := (![#uint32T] "id") in
     let: "$name" := (![#stringT] "name") in
     let: "$startTime" := (![#TimeStamp] "startTime") in
     let: "$endTime" := (![#TimeStamp] "endTime") in
     struct.make #Event [{
       "id" ::= "$id";
       "name" ::= "$name";
       "startTime" ::= "$startTime";
       "endTime" ::= "$endTime"
     }], ![#sliceT] "enc")).

(* go: main.go:7:6 *)
Definition main : val :=
  rec: "main" <> :=
    exception_do (let: "event" := (mem.alloc (type.zero_val #Event)) in
    let: "$r0" := (let: "$id" := #(W32 1) in
    let: "$name" := #"test event"%go in
    let: "$startTime" := (let: "$hour" := #(W32 13) in
    let: "$minute" := #(W32 0) in
    let: "$second" := #(W32 0) in
    struct.make #TimeStamp [{
      "hour" ::= "$hour";
      "minute" ::= "$minute";
      "second" ::= "$second"
    }]) in
    let: "$endTime" := (let: "$hour" := #(W32 14) in
    let: "$minute" := #(W32 0) in
    let: "$second" := #(W32 0) in
    struct.make #TimeStamp [{
      "hour" ::= "$hour";
      "minute" ::= "$minute";
      "second" ::= "$second"
    }]) in
    struct.make #Event [{
      "id" ::= "$id";
      "name" ::= "$name";
      "startTime" ::= "$startTime";
      "endTime" ::= "$endTime"
    }]) in
    do:  ("event" <-[#Event] "$r0");;;
    do:  (let: "$a0" := #"Name:  %s
    Start: %02d:%02d:%02d
    End:   %02d:%02d:%02d
    "%go in
    let: "$a1" := ((let: "$sl0" := (interface.make #""%go #"string"%go (![#stringT] (struct.field_ref #Event #"name"%go "event"))) in
    let: "$sl1" := (interface.make #""%go #"uint32"%go (![#uint32T] (struct.field_ref #TimeStamp #"hour"%go (struct.field_ref #Event #"startTime"%go "event")))) in
    let: "$sl2" := (interface.make #""%go #"uint32"%go (![#uint32T] (struct.field_ref #TimeStamp #"minute"%go (struct.field_ref #Event #"startTime"%go "event")))) in
    let: "$sl3" := (interface.make #""%go #"uint32"%go (![#uint32T] (struct.field_ref #TimeStamp #"second"%go (struct.field_ref #Event #"startTime"%go "event")))) in
    let: "$sl4" := (interface.make #""%go #"uint32"%go (![#uint32T] (struct.field_ref #TimeStamp #"hour"%go (struct.field_ref #Event #"endTime"%go "event")))) in
    let: "$sl5" := (interface.make #""%go #"uint32"%go (![#uint32T] (struct.field_ref #TimeStamp #"minute"%go (struct.field_ref #Event #"endTime"%go "event")))) in
    let: "$sl6" := (interface.make #""%go #"uint32"%go (![#uint32T] (struct.field_ref #TimeStamp #"second"%go (struct.field_ref #Event #"endTime"%go "event")))) in
    slice.literal #interfaceT ["$sl0"; "$sl1"; "$sl2"; "$sl3"; "$sl4"; "$sl5"; "$sl6"])) in
    (func_call #fmt.fmt #"Printf"%go) "$a0" "$a1");;;
    let: "enc" := (mem.alloc (type.zero_val #sliceT)) in
    let: "$r0" := (let: "$a0" := #slice.nil in
    let: "$a1" := (![#Event] "event") in
    (func_call #example.main #"MarshalEvent"%go) "$a0" "$a1") in
    do:  ("enc" <-[#sliceT] "$r0");;;
    let: "newEvent" := (mem.alloc (type.zero_val #Event)) in
    let: ("$ret0", "$ret1") := (let: "$a0" := (![#sliceT] "enc") in
    (func_call #example.main #"UnmarshalEvent"%go) "$a0") in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    do:  ("newEvent" <-[#Event] "$r0");;;
    do:  "$r1";;;
    do:  (let: "$a0" := #"Name:  %s
    Start: %02d:%02d:%02d
    End:   %02d:%02d:%02d
    "%go in
    let: "$a1" := ((let: "$sl0" := (interface.make #""%go #"string"%go (![#stringT] (struct.field_ref #Event #"name"%go "newEvent"))) in
    let: "$sl1" := (interface.make #""%go #"uint32"%go (![#uint32T] (struct.field_ref #TimeStamp #"hour"%go (struct.field_ref #Event #"startTime"%go "newEvent")))) in
    let: "$sl2" := (interface.make #""%go #"uint32"%go (![#uint32T] (struct.field_ref #TimeStamp #"minute"%go (struct.field_ref #Event #"startTime"%go "newEvent")))) in
    let: "$sl3" := (interface.make #""%go #"uint32"%go (![#uint32T] (struct.field_ref #TimeStamp #"second"%go (struct.field_ref #Event #"startTime"%go "newEvent")))) in
    let: "$sl4" := (interface.make #""%go #"uint32"%go (![#uint32T] (struct.field_ref #TimeStamp #"hour"%go (struct.field_ref #Event #"endTime"%go "newEvent")))) in
    let: "$sl5" := (interface.make #""%go #"uint32"%go (![#uint32T] (struct.field_ref #TimeStamp #"minute"%go (struct.field_ref #Event #"endTime"%go "newEvent")))) in
    let: "$sl6" := (interface.make #""%go #"uint32"%go (![#uint32T] (struct.field_ref #TimeStamp #"second"%go (struct.field_ref #Event #"endTime"%go "newEvent")))) in
    slice.literal #interfaceT ["$sl0"; "$sl1"; "$sl2"; "$sl3"; "$sl4"; "$sl5"; "$sl6"])) in
    (func_call #fmt.fmt #"Printf"%go) "$a0" "$a1");;;
    return: #()).

(* go: timestamp.go:13:6 *)
Definition MarshalTimeStamp : val :=
  rec: "MarshalTimeStamp" "prefix" "t" :=
    exception_do (let: "t" := (mem.alloc "t") in
    let: "prefix" := (mem.alloc "prefix") in
    let: "enc" := (mem.alloc (type.zero_val #sliceT)) in
    let: "$r0" := (![#sliceT] "prefix") in
    do:  ("enc" <-[#sliceT] "$r0");;;
    let: "$r0" := (let: "$a0" := (![#sliceT] "enc") in
    let: "$a1" := (![#uint32T] (struct.field_ref #TimeStamp #"hour"%go "t")) in
    (func_call #marshal.marshal #"WriteInt32"%go) "$a0" "$a1") in
    do:  ("enc" <-[#sliceT] "$r0");;;
    let: "$r0" := (let: "$a0" := (![#sliceT] "enc") in
    let: "$a1" := (![#uint32T] (struct.field_ref #TimeStamp #"minute"%go "t")) in
    (func_call #marshal.marshal #"WriteInt32"%go) "$a0" "$a1") in
    do:  ("enc" <-[#sliceT] "$r0");;;
    let: "$r0" := (let: "$a0" := (![#sliceT] "enc") in
    let: "$a1" := (![#uint32T] (struct.field_ref #TimeStamp #"second"%go "t")) in
    (func_call #marshal.marshal #"WriteInt32"%go) "$a0" "$a1") in
    do:  ("enc" <-[#sliceT] "$r0");;;
    return: (![#sliceT] "enc")).

(* go: timestamp.go:21:6 *)
Definition UnmarshalTimeStamp : val :=
  rec: "UnmarshalTimeStamp" "s" :=
    exception_do (let: "s" := (mem.alloc "s") in
    let: "enc" := (mem.alloc (type.zero_val #sliceT)) in
    let: "$r0" := (![#sliceT] "s") in
    do:  ("enc" <-[#sliceT] "$r0");;;
    let: "hour" := (mem.alloc (type.zero_val #uint32T)) in
    let: "minute" := (mem.alloc (type.zero_val #uint32T)) in
    let: "second" := (mem.alloc (type.zero_val #uint32T)) in
    let: ("$ret0", "$ret1") := (let: "$a0" := (![#sliceT] "enc") in
    (func_call #marshal.marshal #"ReadInt32"%go) "$a0") in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    do:  ("hour" <-[#uint32T] "$r0");;;
    do:  ("enc" <-[#sliceT] "$r1");;;
    let: ("$ret0", "$ret1") := (let: "$a0" := (![#sliceT] "enc") in
    (func_call #marshal.marshal #"ReadInt32"%go) "$a0") in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    do:  ("minute" <-[#uint32T] "$r0");;;
    do:  ("enc" <-[#sliceT] "$r1");;;
    let: ("$ret0", "$ret1") := (let: "$a0" := (![#sliceT] "enc") in
    (func_call #marshal.marshal #"ReadInt32"%go) "$a0") in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    do:  ("second" <-[#uint32T] "$r0");;;
    do:  ("enc" <-[#sliceT] "$r1");;;
    return: (let: "$hour" := (![#uint32T] "hour") in
     let: "$minute" := (![#uint32T] "minute") in
     let: "$second" := (![#uint32T] "second") in
     struct.make #TimeStamp [{
       "hour" ::= "$hour";
       "minute" ::= "$minute";
       "second" ::= "$second"
     }], ![#sliceT] "enc")).

Definition vars' : list (go_string * go_type) := [].

Definition functions' : list (go_string * val) := [("MarshalCalendar"%go, MarshalCalendar); ("UnmarshalCalendar"%go, UnmarshalCalendar); ("MarshalEvent"%go, MarshalEvent); ("UnmarshalEvent"%go, UnmarshalEvent); ("main"%go, main); ("MarshalTimeStamp"%go, MarshalTimeStamp); ("UnmarshalTimeStamp"%go, UnmarshalTimeStamp)].

Definition msets' : list (go_string * (list (go_string * val))) := [("Calendar"%go, []); ("Calendar'ptr"%go, []); ("Event"%go, []); ("Event'ptr"%go, []); ("TimeStamp"%go, []); ("TimeStamp'ptr"%go, [])].

#[global] Instance info' : PkgInfo example.main :=
  {|
    pkg_vars := vars';
    pkg_functions := functions';
    pkg_msets := msets';
    pkg_imported_pkgs := [marshal.marshal; fmt.fmt];
  |}.

Definition initialize' : val :=
  rec: "initialize'" <> :=
    globals.package_init example.main (λ: <>,
      exception_do (do:  fmt.initialize';;;
      do:  marshal.initialize')
      ).

End code.
End main.
